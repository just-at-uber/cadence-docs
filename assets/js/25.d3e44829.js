(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{409:function(e,t,r){"use strict";r.r(t);var a=r(8),s=Object(a.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"event-handling"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#event-handling"}},[e._v("#")]),e._v(" Event handling")]),e._v(" "),r("p",[e._v("Fault-oblivious stateful "),r("Term",{attrs:{term:"workflow",show:"workflows"}}),e._v(" can be "),r("Term",{attrs:{term:"signal",show:"signalled"}}),e._v(" about an external "),r("Term",{attrs:{term:"event"}}),e._v(". A "),r("Term",{attrs:{term:"signal"}}),e._v(" is always point to point destined to a specific "),r("Term",{attrs:{term:"workflow"}}),e._v(" instance. "),r("Term",{attrs:{term:"signal",show:"Signals"}}),e._v(" are always processed in the order in which they are received.")],1),e._v(" "),r("p",[e._v("There are multiple scenarios for which "),r("Term",{attrs:{term:"signal",show:"signals"}}),e._v(" are useful.")],1),e._v(" "),r("h2",{attrs:{id:"event-aggregation-and-correlation"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#event-aggregation-and-correlation"}},[e._v("#")]),e._v(" Event Aggregation and Correlation")]),e._v(" "),r("p",[e._v("Cadence is not a replacement for generic stream processing engines like Apache Flink or Apache Spark. But in certain scenarios it is a better fit. For example, when all "),r("Term",{attrs:{term:"event",show:"events"}}),e._v(" that should be aggregated and correlated are always applied to to some business entity with a clear ID. And then when a certain condition is met, actions should be executed.")],1),e._v(" "),r("p",[e._v("The main limitation is that a single Cadence "),r("Term",{attrs:{term:"workflow"}}),e._v(" has a pretty limited throughput, while the number of "),r("Term",{attrs:{term:"workflow",show:"workflows"}}),e._v(" is practically unlimited. So if you need to aggregate "),r("Term",{attrs:{term:"event",show:"events"}}),e._v(" per customer, and your application has 100 million customers and each customer doesn't generate more than 20 "),r("Term",{attrs:{term:"event",show:"events"}}),e._v(" per second, then Cadence would work fine. But if you want to aggregate all "),r("Term",{attrs:{term:"event",show:"events"}}),e._v(" for US customers then the rate of these "),r("Term",{attrs:{term:"event",show:"events"}}),e._v(" would be beyond the single "),r("Term",{attrs:{term:"workflow"}}),e._v(" capacity.")],1),e._v(" "),r("p",[e._v("For example, an IoT device generates "),r("Term",{attrs:{term:"event",show:"events"}}),e._v(" and a certain sequence of "),r("Term",{attrs:{term:"event",show:"events"}}),e._v(" indicates that the device should be reprovisioned. A "),r("Term",{attrs:{term:"workflow"}}),e._v(" instance per device would be created and each instance would manage the state machine of the device and execute reprovision "),r("Term",{attrs:{term:"activity"}}),e._v(" when necessary.")],1),e._v(" "),r("p",[e._v("Another use case is a customer loyalty program. Every time a customer makes a purchase, an "),r("Term",{attrs:{term:"event"}}),e._v(" is generated into Apache Kafka for downstream systems to process. A loyalty service Kafka consumer receives the "),r("Term",{attrs:{term:"event"}}),e._v(" and "),r("Term",{attrs:{term:"signal",show:"signals"}}),e._v(" a customer "),r("Term",{attrs:{term:"workflow"}}),e._v(" about the purchase using the Cadence "),r("code",[e._v("signalWorkflowExecution")]),e._v(" API. The "),r("Term",{attrs:{term:"workflow"}}),e._v(" accumulates the count of the purchases. If a specified threshold is achieved, the "),r("Term",{attrs:{term:"workflow"}}),e._v(" executes an "),r("Term",{attrs:{term:"activity"}}),e._v(" that notifies some external service that the customer has reached the next level of loyalty program. The "),r("Term",{attrs:{term:"workflow"}}),e._v(" also executes "),r("Term",{attrs:{term:"activity",show:"activities"}}),e._v(" to periodically message the customer about their current status.")],1),e._v(" "),r("h2",{attrs:{id:"human-tasks"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#human-tasks"}},[e._v("#")]),e._v(" Human Tasks")]),e._v(" "),r("p",[e._v("A lot of business processes involve human participants. The standard Cadence pattern for implementing an external interaction is to execute an "),r("Term",{attrs:{term:"activity"}}),e._v(" that creates a human "),r("Term",{attrs:{term:"task"}}),e._v(" in an external system. It can be an email with a form, or a record in some external database, or a mobile app notification. When a user changes the status of the "),r("Term",{attrs:{term:"task"}}),e._v(", a "),r("Term",{attrs:{term:"signal"}}),e._v(" is sent to the corresponding "),r("Term",{attrs:{term:"workflow"}}),e._v(". For example, when the form is submitted, or a mobile app notification is acknowledged. Some "),r("Term",{attrs:{term:"task",show:"tasks"}}),e._v(" have multiple possible actions like claim, return, complete, reject. So multiple "),r("Term",{attrs:{term:"signal",show:"signals"}}),e._v(" can be sent in relation to it.")],1),e._v(" "),r("h2",{attrs:{id:"process-execution-alteration"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#process-execution-alteration"}},[e._v("#")]),e._v(" Process Execution Alteration")]),e._v(" "),r("p",[e._v("Some business processes should change their behavior if some external "),r("Term",{attrs:{term:"event"}}),e._v(" has happened. For example, while executing an order shipment "),r("Term",{attrs:{term:"workflow"}}),e._v(", any change in item quantity could be delivered in a form of a "),r("Term",{attrs:{term:"signal"}}),e._v(".")],1),e._v(" "),r("p",[e._v("Another example is a service deployment "),r("Term",{attrs:{term:"workflow"}}),e._v(". While rolling out new software version to a Kubernetes cluster some problem was identified. A "),r("Term",{attrs:{term:"signal"}}),e._v(" can be used to ask the "),r("Term",{attrs:{term:"workflow"}}),e._v(" to pause while the problem is investigated. Then either a continue or a rollback "),r("Term",{attrs:{term:"signal"}}),e._v(" can be used to execute the appropriate action.")],1),e._v(" "),r("h2",{attrs:{id:"synchronization"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#synchronization"}},[e._v("#")]),e._v(" Synchronization")]),e._v(" "),r("p",[e._v("Cadence "),r("Term",{attrs:{term:"workflow",show:"workflows"}}),e._v(" are strongly consistent so they can be used as a synchronization point for executing actions. For example, there is a requirement that all messages for a single user are processed sequentially but the underlying messaging infrastructure can deliver them in parallel. The Cadence solution would be to have a "),r("Term",{attrs:{term:"workflow"}}),e._v(" per user and "),r("Term",{attrs:{term:"signal"}}),e._v(" it when an "),r("Term",{attrs:{term:"event"}}),e._v(" is received. Then the "),r("Term",{attrs:{term:"workflow"}}),e._v(" would buffer all "),r("Term",{attrs:{term:"signal",show:"signals"}}),e._v(" in an internal data structure and then call an "),r("Term",{attrs:{term:"activity"}}),e._v(" for every "),r("Term",{attrs:{term:"signal"}}),e._v(" received. See the following "),r("a",{attrs:{href:"https://stackoverflow.com/a/56615120/1664318",target:"_blank",rel:"noopener noreferrer"}},[e._v("Stack Overflow answer"),r("OutboundLink")],1),e._v(" for an example.")],1)])}),[],!1,null,null,null);t.default=s.exports}}]);