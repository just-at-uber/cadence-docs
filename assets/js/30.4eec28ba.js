(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{414:function(t,e,a){"use strict";a.r(e);var r=a(8),s=Object(r.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"cross-dc-replication"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cross-dc-replication"}},[t._v("#")]),t._v(" Cross-DC replication")]),t._v(" "),a("p",[t._v("The Cadence Global "),a("Term",{attrs:{term:"domain",show:"Domain"}}),t._v(" feature provides clients with the capability to continue their "),a("Term",{attrs:{term:"workflow_execution"}}),t._v(" from another\ncluster in the event of a datacenter failover. Although you can configure a Global "),a("Term",{attrs:{term:"domain",show:"Domain"}}),t._v(" to be replicated to any number of\nclusters, it is only considered active in a single cluster.")],1),t._v(" "),a("h2",{attrs:{id:"global-domains-architecture"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#global-domains-architecture"}},[t._v("#")]),t._v(" Global Domains Architecture")]),t._v(" "),a("p",[t._v("Cadence has introduced a new top level entity, Global "),a("Term",{attrs:{term:"domain",show:"Domains"}}),t._v(", which provides support for replication of "),a("Term",{attrs:{term:"workflow"}}),t._v("\nexecution across clusters. Client applications need to run "),a("Term",{attrs:{term:"worker",show:"workers"}}),t._v(" polling on "),a("Term",{attrs:{term:"activity",show:"Activity"}}),t._v("/"),a("Term",{attrs:{term:"decision_task",show:"Decision_tasks"}}),t._v(" on all clusters.\nCadence will only dispatch tasks on the current active cluster; "),a("Term",{attrs:{term:"worker",show:"workers"}}),t._v(" on the standby cluster will sit idle\nuntil the Global "),a("Term",{attrs:{term:"domain",show:"Domain"}}),t._v(" is failed over.")],1),t._v(" "),a("p",[t._v("Because Cadence is a service that provides highly consistent semantics, we only allow external "),a("Term",{attrs:{term:"event",show:"events"}}),t._v(" like\n"),a("strong",[t._v("StartWorkflowExecution")]),t._v(", "),a("strong",[t._v("SignalWorkflowExecution")]),t._v(", etc. on an active cluster. Global "),a("Term",{attrs:{term:"domain",show:"Domains"}}),t._v(" relies on light-weight\ntransactions (paxos) on the local cluster (Local_Quorum) to update the "),a("Term",{attrs:{term:"workflow_execution"}}),t._v(" state and create replication\n"),a("Term",{attrs:{term:"task",show:"tasks"}}),t._v(" which are applied asynchronously to replicate state across clusters. If an application makes these API calls on a\ncluster where Global "),a("Term",{attrs:{term:"domain",show:"Domain"}}),t._v(" is in standby mode, Cadence will reject those calls with "),a("strong",[t._v("DomainNotActiveError")]),t._v(", which\ncontains the name of the current active cluster. It is the responsibility of the application to forward the external\n"),a("Term",{attrs:{term:"event"}}),t._v(" to the cluster that is currently active.")],1),t._v(" "),a("h2",{attrs:{id:"new-config-for-global-domains"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#new-config-for-global-domains"}},[t._v("#")]),t._v(" New config for Global Domains")]),t._v(" "),a("h3",{attrs:{id:"isglobal"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#isglobal"}},[t._v("#")]),t._v(" IsGlobal")]),t._v(" "),a("p",[t._v("This config is used to distinguish "),a("Term",{attrs:{term:"domain",show:"domains"}}),t._v(" local to the cluster from the global "),a("Term",{attrs:{term:"domain"}}),t._v(". It controls the creation of\nreplication "),a("Term",{attrs:{term:"task",show:"tasks"}}),t._v(" on updates allowing the state to be replicated across clusters. This is a read-only setting that can\nonly be set when the "),a("Term",{attrs:{term:"domain"}}),t._v(" is provisioned.")],1),t._v(" "),a("h3",{attrs:{id:"clusters"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#clusters"}},[t._v("#")]),t._v(" Clusters")]),t._v(" "),a("p",[t._v("A list of clusters where the "),a("Term",{attrs:{term:"domain"}}),t._v(" can fail over to, including the current active cluster.\nThis is also a read-only setting that can only be set when the "),a("Term",{attrs:{term:"domain"}}),t._v(" is provisioned. A re-replication feature on the\nroadmap will allow updating this config to add/remove clusters in the future.")],1),t._v(" "),a("h3",{attrs:{id:"active-cluster-name"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#active-cluster-name"}},[t._v("#")]),t._v(" Active Cluster Name")]),t._v(" "),a("p",[t._v("Name of the current active cluster for the Global "),a("Term",{attrs:{term:"domain",show:"Domain"}}),t._v(". This config is updated each time the Global "),a("Term",{attrs:{term:"domain",show:"Domain"}}),t._v(" is failed over to\nanother cluster.")],1),t._v(" "),a("h3",{attrs:{id:"failover-version"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#failover-version"}},[t._v("#")]),t._v(" Failover Version")]),t._v(" "),a("p",[t._v("Unique failover version which also represents the current active cluster for Global "),a("Term",{attrs:{term:"domain",show:"Domain"}}),t._v(". Cadence allows failover to\nbe triggered from any cluster, so failover version is designed in a way to not allow conflicts if failover is mistakenly\ntriggered simultaneously on two clusters.")],1),t._v(" "),a("h2",{attrs:{id:"conflict-resolution"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#conflict-resolution"}},[t._v("#")]),t._v(" Conflict Resolution")]),t._v(" "),a("p",[t._v("Unlike local "),a("Term",{attrs:{term:"domain",show:"domains"}}),t._v(" which provide at-most-once semantics for "),a("Term",{attrs:{term:"activity"}}),t._v(" execution, Global "),a("Term",{attrs:{term:"domain",show:"Domains"}}),t._v(" can only support at-least-once\nsemantics. Cadence XDC relies on asynchronous replication of "),a("Term",{attrs:{term:"event",show:"events"}}),t._v(" across clusters, so in the event of a failover\nit is possible that "),a("Term",{attrs:{term:"activity"}}),t._v(" gets dispatched again on the new active cluster due to a replication "),a("Term",{attrs:{term:"task"}}),t._v(" lag. This also\nmeans that whenever "),a("Term",{attrs:{term:"workflow_execution"}}),t._v(" is updated after a failover by the new cluster, any previous replication "),a("Term",{attrs:{term:"task",show:"tasks"}}),t._v("\nfor that execution cannot be applied. This results in loss of some progress made by the "),a("Term",{attrs:{term:"workflow_execution"}}),t._v(" in the\nprevious active cluster. During such conflict resolution, Cadence re-injects any external "),a("Term",{attrs:{term:"event",show:"events"}}),t._v(" like "),a("Term",{attrs:{term:"signal",show:"Signals"}}),t._v(" to the\nnew history before discarding replication "),a("Term",{attrs:{term:"task",show:"tasks"}}),t._v(". Even though some progress could rollback during failovers, Cadence\nprovides the guarantee that "),a("Term",{attrs:{term:"workflow",show:"workflows"}}),t._v(" wonâ€™t get stuck and will continue to make forward progress.")],1),t._v(" "),a("h2",{attrs:{id:"visibility-api"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#visibility-api"}},[t._v("#")]),t._v(" Visibility API")]),t._v(" "),a("p",[t._v("All Visibility APIs are allowed on both active and standby clusters. This enables\n"),a("a",{attrs:{href:"https://github.com/uber/cadence-web",target:"_blank",rel:"noopener noreferrer"}},[t._v("Cadence Web"),a("OutboundLink")],1),t._v(" to work seamlessly for Global "),a("Term",{attrs:{term:"domain",show:"Domains"}}),t._v(" as all visibility records for\n"),a("Term",{attrs:{term:"workflow_execution",show:"workflow_executions"}}),t._v(" can be queried from any cluster the "),a("Term",{attrs:{term:"domain"}}),t._v(" is replicated to. Applications making API calls directly\nto the Cadence Visibility API will continue to work even if a Global "),a("Term",{attrs:{term:"domain",show:"Domain"}}),t._v(" is in standby mode. However, they might see\na lag due to replication delay when "),a("Term",{attrs:{term:"query",show:"querying"}}),t._v(" the "),a("Term",{attrs:{term:"workflow_execution"}}),t._v(" state from a standby cluster.")],1),t._v(" "),a("h2",{attrs:{id:"cli"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cli"}},[t._v("#")]),t._v(" CLI")]),t._v(" "),a("p",[t._v("The Cadence "),a("Term",{attrs:{term:"CLI"}}),t._v(" can also be used to "),a("Term",{attrs:{term:"query"}}),t._v(" the "),a("Term",{attrs:{term:"domain"}}),t._v(" config or perform failovers. Here are some useful commands.")],1),t._v(" "),a("h3",{attrs:{id:"query-global-domain"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#query-global-domain"}},[t._v("#")]),t._v(" Query Global Domain")]),t._v(" "),a("p",[t._v("The following command can be used to describe Global "),a("Term",{attrs:{term:"domain",show:"Domain"}}),t._v(" metadata:")],1),t._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[t._v("$ cadence --do cadence-canary-xdc d desc\nName: cadence-canary-xdc\nDescription: cadence canary cross "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("dc")]),t._v(" testing domain\nOwnerEmail: cadence-dev@cadenceworkflow.io\nDomainData:\nStatus: REGISTERED\nRetentionInDays: "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("7")]),t._v("\nEmitMetrics: "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),t._v("\nActiveClusterName: dc1\nClusters: dc1, dc2\n")])])]),a("h3",{attrs:{id:"failover-global-domain"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#failover-global-domain"}},[t._v("#")]),t._v(" Failover Global Domain")]),t._v(" "),a("p",[t._v("The following command can be used to failover Global "),a("Term",{attrs:{term:"domain",show:"Domain"}}),t._v(" "),a("em",[t._v("my-domain-global")]),t._v(" to the "),a("em",[t._v("dc2")]),t._v(" cluster:")],1),t._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[t._v("$ cadence --do my-domain-global d up --ac dc2\n")])])]),a("h2",{attrs:{id:"faq"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#faq"}},[t._v("#")]),t._v(" FAQ")]),t._v(" "),a("h3",{attrs:{id:"what-happens-to-outstanding-activities-after-failover"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#what-happens-to-outstanding-activities-after-failover"}},[t._v("#")]),t._v(" What happens to outstanding activities after failover?")]),t._v(" "),a("p",[t._v("Cadence does not forward "),a("Term",{attrs:{term:"activity"}}),t._v(" completions across clusters. Any outstanding "),a("Term",{attrs:{term:"activity"}}),t._v(" will eventually timeout based\non the configuration. Your application should have retry logic in place so that the "),a("Term",{attrs:{term:"activity"}}),t._v(" gets retried and dispatched\nagain to a "),a("Term",{attrs:{term:"worker"}}),t._v(" after the failover to the new DC. Handling this is pretty much the same as "),a("Term",{attrs:{term:"activity"}}),t._v(" timeout caused by\na "),a("Term",{attrs:{term:"worker"}}),t._v(" restart even without Global "),a("Term",{attrs:{term:"domain",show:"Domains"}}),t._v(".")],1),t._v(" "),a("h3",{attrs:{id:"what-happens-when-a-start-or-signal-api-call-is-made-to-a-standby-cluster"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#what-happens-when-a-start-or-signal-api-call-is-made-to-a-standby-cluster"}},[t._v("#")]),t._v(" What happens when a start or signal API call is made to a standby cluster?")]),t._v(" "),a("p",[t._v("Cadence will reject the call and return "),a("strong",[t._v("DomainNotActiveError")]),t._v(". It is the responsibility of the application to forward\nthe failed call to active cluster based on information provided in the error.")]),t._v(" "),a("h3",{attrs:{id:"what-is-the-recommended-pattern-to-send-external-events-to-an-active-cluster"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#what-is-the-recommended-pattern-to-send-external-events-to-an-active-cluster"}},[t._v("#")]),t._v(" What is the recommended pattern to send external events to an active cluster?")]),t._v(" "),a("p",[t._v("The recommendation at this point is to publish "),a("Term",{attrs:{term:"event",show:"events"}}),t._v(" to a Kafka topic if they can be generated in any DC.\nThen, have a consumer that consumes from the aggregated Kafka topic in the same DC and sends them to Cadence. Both the\nKafka consumer and Global "),a("Term",{attrs:{term:"domain",show:"Domain"}}),t._v(" need to be failed over together.")],1)])}),[],!1,null,null,null);e.default=s.exports}}]);